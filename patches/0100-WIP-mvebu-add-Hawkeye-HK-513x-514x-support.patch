From a88f570123f8b188b20de15e8ed6a3e8bcd86ba1 Mon Sep 17 00:00:00 2001
From: Jonas Gorski <jonas.gorski@bisdn.de>
Date: Thu, 1 Aug 2024 11:19:15 +0000
Subject: [PATCH 1/4] WIP: mvebu: add Hawkeye HK-513x/514x support

TODO:

* add hawkeye drivers
* drop/rework unreleated changes from hawkeye patch
* adapt to hawkeye partition layout?
* test SFP+/10G modules
* test sysupgrade
* verify crypto? (requires nda firmware)
* phy drivers?

Changes from Hawkeye:

* use OpenWrt standard partiton layout
* move dts files out of patch
* disable second sec engine in dts file
* drop debian related changes from patch
* add board names to compatible in dts files

Signed-off-by: Jonas Gorski <jonas.gorski@bisdn.de>
---
 .../base-files/etc/board.d/02_network         |   6 +
 .../base-files/lib/upgrade/platform.sh        |   6 +
 .../arch/arm64/boot/dts/marvell/hk5130.dts    | 490 ++++++++++++++++++
 .../arch/arm64/boot/dts/marvell/hk5131.dts    |  19 +
 .../arch/arm64/boot/dts/marvell/hk5140.dts    |   1 +
 .../arch/arm64/boot/dts/marvell/hk5141.dts    |   1 +
 target/linux/mvebu/image/cortexa72.mk         |  11 +
 target/linux/mvebu/image/hawkeye.bootscript   |  18 +
 .../patches-5.15/920-hawkeye-hk5310.patch     |  87 ++++
 9 files changed, 639 insertions(+)
 create mode 100644 target/linux/mvebu/files/arch/arm64/boot/dts/marvell/hk5130.dts
 create mode 100644 target/linux/mvebu/files/arch/arm64/boot/dts/marvell/hk5131.dts
 create mode 120000 target/linux/mvebu/files/arch/arm64/boot/dts/marvell/hk5140.dts
 create mode 120000 target/linux/mvebu/files/arch/arm64/boot/dts/marvell/hk5141.dts
 create mode 100644 target/linux/mvebu/image/hawkeye.bootscript
 create mode 100644 target/linux/mvebu/patches-5.15/920-hawkeye-hk5310.patch

diff --git a/target/linux/mvebu/cortexa72/base-files/etc/board.d/02_network b/target/linux/mvebu/cortexa72/base-files/etc/board.d/02_network
index 6a5861084e..e7bd57ab26 100644
--- a/target/linux/mvebu/cortexa72/base-files/etc/board.d/02_network
+++ b/target/linux/mvebu/cortexa72/base-files/etc/board.d/02_network
@@ -13,6 +13,12 @@ case "$board" in
 globalscale,mochabin)
 	ucidef_set_interfaces_lan_wan "lan0 lan1 lan2 lan3" "eth0 eth2"
 	;;
+hawkeye,hk-5130)
+	ucidef_set_interfaces_lan_wan "eth1 eth2 eth4 eth5" "eth0 eth3"
+	;;
+hawkeye,hk-5131)
+	ucidef_set_interfaces_lan "eth0 eth1 eth2 eth3"
+	;;
 iei,puzzle-m901)
 	ucidef_set_interfaces_lan_wan "eth1 eth2 eth3 eth4 eth5" "eth0"
 	;;
diff --git a/target/linux/mvebu/cortexa72/base-files/lib/upgrade/platform.sh b/target/linux/mvebu/cortexa72/base-files/lib/upgrade/platform.sh
index dc964a3117..5383407947 100755
--- a/target/linux/mvebu/cortexa72/base-files/lib/upgrade/platform.sh
+++ b/target/linux/mvebu/cortexa72/base-files/lib/upgrade/platform.sh
@@ -10,6 +10,8 @@ REQUIRE_IMAGE_METADATA=1
 platform_check_image() {
 	case "$(board_name)" in
 	globalscale,mochabin|\
+	hawkeye,hk-5130|\
+	hawkeye,hk-5131|\
 	iei,puzzle-m901|\
 	iei,puzzle-m902|\
 	marvell,armada8040-mcbin-doubleshot|\
@@ -30,6 +32,8 @@ platform_do_upgrade() {
 		platform_do_upgrade_emmc "$1"
 		;;
 	globalscale,mochabin|\
+	hawkeye,hk-5130|\
+	hawkeye,hk-5131|\
 	marvell,armada8040-mcbin-doubleshot|\
 	marvell,armada8040-mcbin-singleshot|\
 	marvell,armada8040-clearfog-gt-8k)
@@ -43,6 +47,8 @@ platform_do_upgrade() {
 platform_copy_config() {
 	case "$(board_name)" in
 	globalscale,mochabin|\
+	hawkeye,hk-5130|\
+	hawkeye,hk-5131|\
 	iei,puzzle-m901|\
 	iei,puzzle-m902|\
 	marvell,armada8040-mcbin-doubleshot|\
diff --git a/target/linux/mvebu/files/arch/arm64/boot/dts/marvell/hk5130.dts b/target/linux/mvebu/files/arch/arm64/boot/dts/marvell/hk5130.dts
new file mode 100644
index 0000000000..de22037c41
--- /dev/null
+++ b/target/linux/mvebu/files/arch/arm64/boot/dts/marvell/hk5130.dts
@@ -0,0 +1,490 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * Device tree for the HK-5130 board which referred to cn9130-db.dtsi.
+ */
+
+#include "cn9130.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "HK-5130 Series";
+	compatible = "hawkeye,hk-5130", "marvell,cn9131", "marvell,cn9130",
+			"marvell,armada-ap807-quad", "marvell,armada-ap807";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		serial0 = &uart0;
+		serial1 = &cp0_uart2;
+		gpio1 = &cp0_gpio1;
+		gpio2 = &cp0_gpio2;
+		gpio3 = &cp1_gpio1;
+		gpio4 = &cp1_gpio2;
+		i2c0 = &cp0_mss_i2c;
+		i2c1 = &cp0_i2c1;
+		i2c2 = &cp1_mss_i2c;
+		i2c3 = &cp1_i2c0;
+		ethernet0 = &cp0_eth1;
+		ethernet1 = &cp0_eth2;
+		ethernet2 = &cp1_eth1;
+		ethernet3 = &cp1_eth2;
+		ethernet4 = &cp0_eth0;
+		ethernet5 = &cp1_eth0;
+		spi0 = &cp0_spi0;
+		spi1 = &cp1_spi1;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	cp0_reg_usb3_vbus0: cp0_usb3_vbus@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "cp0-xhci0-vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&cp0_gpio2 12 0>;
+	};
+
+	cp0_usb3_0_phy0: cp0_usb3_phy@0 {
+		compatible = "usb-nop-xceiv";
+		vcc-supply = <&cp0_reg_usb3_vbus0>;
+	};
+
+	cp0_reg_usb3_vbus1: cp0_usb3_vbus@1 {
+		compatible = "regulator-fixed";
+		regulator-name = "cp0-xhci1-vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+	};
+
+	cp0_usb3_0_phy1: cp0_usb3_phy@1 {
+		compatible = "usb-nop-xceiv";
+		vcc-supply = <&cp0_reg_usb3_vbus1>;
+	};
+
+	cp0_sfp_eth0: cp0-sfp-eth0 {
+		compatible = "sff,sfp";
+		i2c-bus = <&cp0_mss_i2c>;
+		mod-def0-gpio = <&cp1_gpio1 31 GPIO_ACTIVE_LOW>;
+		tx-disable-gpio = <&expander0 9 GPIO_ACTIVE_HIGH>;
+		tx-fault-gpio = <&expander0 8 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&cp1_sfp0_pins>;
+		maximum-power-milliwatt = <2000>;
+		status = "okay";
+	};
+
+	cp1_reg_usb3_vbus0: cp1_usb3_vbus@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "cp1-xhci0-vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+	};
+
+	cp1_usb3_0_phy0: cp1_usb3_phy@0 {
+		compatible = "usb-nop-xceiv";
+		vcc-supply = <&cp1_reg_usb3_vbus0>;
+	};
+
+	cp1_reg_usb3_vbus1: cp1_usb3_vbus@1 {
+		compatible = "regulator-fixed";
+		regulator-name = "cp1-xhci1-vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+	};
+
+	cp1_usb3_0_phy1: cp1_usb3_phy@1 {
+		compatible = "usb-nop-xceiv";
+		vcc-supply = <&cp1_reg_usb3_vbus1>;
+	};
+
+	cp1_sfp_eth0: cp1-sfp-eth0 {
+		compatible = "sff,sfp";
+		i2c-bus = <&cp1_i2c0>;
+		mod-def0-gpio = <&cp1_gpio2 0 GPIO_ACTIVE_LOW>;
+		tx-disable-gpio = <&expander0 11 GPIO_ACTIVE_HIGH>;
+		tx-fault-gpio = <&expander0 10 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&cp1_sfp1_pins>;
+		maximum-power-milliwatt = <2000>;
+		status = "okay";
+	};
+
+	irq-buttons {
+		compatible = "hawkeye,irq-buttons";
+		btn1 {
+			interrupt-parent = <&cp0_gpio2>;
+			interrupts = <23 IRQ_TYPE_EDGE_RISING>;
+		};
+		btn2 {
+			interrupt-parent = <&cp0_gpio2>;
+			interrupts = <22 IRQ_TYPE_EDGE_RISING>;
+		};
+	};
+
+	gpio-poweroff {
+		compatible = "gpio-poweroff";
+		gpios = <&expander0 15 1>;
+		force;
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+		stat-green {
+			gpios = <&cp0_gpio1 29 GPIO_ACTIVE_LOW>;
+			default-state = "on";
+		};
+		stat-red {
+			gpios = <&cp0_gpio1 30 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+/* on-board eMMC */
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	bus-width = <8>;
+	mmc-ddr-1_8v;
+	mmc-hs400-1_8v;
+	status = "okay";
+};
+
+&cp0_uart2 {
+	status = "okay";
+};
+
+&cp0_crypto {
+	status = "okay";
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	managed = "in-band-status";
+	phy-mode = "10gbase-kr";
+	phys = <&cp0_comphy4 0>;
+	sfp = <&cp0_sfp_eth0>;
+};
+
+&cp0_eth1 {
+	status = "okay";
+	managed = "in-band-status";
+	phy = <&cp0_phy0>;
+	phy-mode = "sgmii";
+	phys = <&cp0_comphy0 1>;
+};
+
+&cp0_eth2 {
+	status = "okay";
+	managed = "in-band-status";
+	phy = <&cp0_phy1>;
+	phy-mode = "sgmii";
+	phys = <&cp0_comphy1 2>;
+};
+
+&cp0_gpio1 {
+	status = "okay";
+};
+
+&cp0_gpio2 {
+	status = "okay";
+};
+
+&cp0_mss_i2c {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_mss_i2c_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+
+	expander0: pca953x@20 {
+		compatible = "nxp,pca9555";
+		gpio-controller;
+		#gpio-cells = <2>;
+		reg = <0x20>;
+		status = "okay";
+	};
+
+};
+
+&cp0_i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c1_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+
+	temp@2f {
+		compatible = "hawkeye,max6639";
+		reg = <0x2f>;
+		skip-init;
+	};
+};
+
+&cp0_mdio {
+	status = "okay";
+
+	cp0_phy0: ethernet-phy@2 {
+		reg = <2>;
+	};
+
+	cp0_phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+
+&cp0_spi0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi0_pins>;
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor";
+		reg = <0x0>;
+		/* On-board MUX does not allow higher frequencies */
+		spi-max-frequency = <40000000>;
+
+	};
+};
+
+&cp0_pinctrl {
+	compatible = "marvell,cp115-standalone-pinctrl";
+
+	cp0_mss_i2c_pins: cp0-i2c-pins-0 {
+		marvell,pins = "mpp0", "mpp1";
+		marvell,function = "mss_i2c";
+	};
+	cp0_i2c1_pins: cp0-i2c-pins-1 {
+		marvell,pins = "mpp2", "mpp3";
+		marvell,function = "i2c1";
+	};
+	cp0_spi0_pins: cp0-spi-pins-0 {
+		marvell,pins = "mpp56", "mpp57", "mpp58", "mpp59";
+		marvell,function = "spi0";
+	};
+};
+
+&cp0_utmi {
+	status = "okay";
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+	usb-phy = <&cp0_usb3_0_phy0>;
+	phys = <&cp0_comphy2 0>, <&cp0_utmi0>;
+	phy-names = "usb3", "utmi";
+	dr_mode = "host";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+	usb-phy = <&cp0_usb3_0_phy1>;
+	phys =  <&cp0_utmi1>;
+	phy-names = "utmi";
+	dr_mode = "host";
+};
+
+
+/*
+ * Instantiate the first slave CP115 on MCi1
+ */
+
+#define CP11X_NAME              cp1
+#define CP11X_NUM               1
+#define CP11X_BASE              f6000000
+#define CP11X_PCIEx_MEM_BASE(iface) (0xe5000000 + (iface * 0x1000000))
+#define CP11X_PCIEx_MEM_SIZE(iface) 0xf00000
+#define CP11X_PCIE0_BASE        f6600000
+#define CP11X_PCIE1_BASE        f6620000
+#define CP11X_PCIE2_BASE        f6640000
+
+#include "armada-cp115.dtsi"
+
+#undef CP11X_NAME
+#undef CP11X_NUM
+#undef CP11X_BASE
+#undef CP11X_PCIEx_MEM_BASE
+#undef CP11X_PCIEx_MEM_SIZE
+#undef CP11X_PCIE0_BASE
+#undef CP11X_PCIE1_BASE
+#undef CP11X_PCIE2_BASE
+
+&cp1_pinctrl {
+	compatible = "marvell,cp115-standalone-pinctrl";
+
+	cp1_mss_i2c_pins: cp1-i2c-pins-0 {
+		marvell,pins = "mpp29", "mpp30";
+		marvell,function = "mss_i2c";
+	};
+	cp1_i2c0_pins: cp1-i2c-pins-1 {
+		marvell,pins = "mpp37", "mpp38";
+		marvell,function = "i2c0";
+	};
+	cp1_spi1_pins: cp1-spi-pins-0 {
+		marvell,pins = "mpp47", "mpp48", "mpp49", "mpp50";
+		marvell,function = "spi1";
+	};
+	cp1_sdhci_cd_pins: cp1-sdhci-cd-pins-0 {
+		marvell,pins = "mpp55";
+		marvell,function = "sdio";
+	};
+	cp1_sdhci_pins: cp1-sdhci-pins-0 {
+		marvell,pins = "mpp56", "mpp57", "mpp58", "mpp59",
+				"mpp60", "mpp61";
+		marvell,function = "sdio";
+	};
+	cp1_sfp0_pins: cp1-sfp-pins-0 {
+		marvell,pins = "mpp31";
+		marvell,function = "gpio";
+	};
+	cp1_sfp1_pins: cp1-sfp-pins-1 {
+		marvell,pins = "mpp32";
+		marvell,function = "gpio";
+	};
+};
+
+&cp1_mss_i2c {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_mss_i2c_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp1_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp1_spi1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+
+	tpm: npct75x@0 {
+		compatible = "tcg,tpm_tis-spi";
+		spi-max-frequency = <50000000>;
+		reg = <0>;
+	};
+};
+
+&cp1_crypto {
+	/*
+	 * The cryptographic engine found on the cp110
+	 * master is enabled by default at the SoC
+	 * level. Because it is not possible as of now
+	 * to enable two cryptographic engines in
+	 * parallel, disable this one by default.
+	 */
+	status = "disabled";
+};
+
+&cp1_gpio1 {
+	status = "okay";
+};
+
+&cp1_gpio2 {
+	status = "okay";
+};
+
+&cp1_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_sdhci_pins &cp1_sdhci_cd_pins>;
+	bus-width = <4>;
+	cd-gpios = <&cp1_gpio2 23 GPIO_ACTIVE_LOW>;
+	no-1-8-v;
+	status = "okay";
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+&cp1_eth0 {
+	status = "okay";
+	managed = "in-band-status";
+	phy-mode = "10gbase-kr";
+	phys = <&cp1_comphy2 0>;
+	sfp = <&cp1_sfp_eth0>;
+};
+
+&cp1_eth1 {
+	status = "okay";
+	managed = "in-band-status";
+	phy = <&cp1_phy0>;
+	phy-mode = "sgmii";
+	phys = <&cp1_comphy0 1>;
+};
+
+&cp1_eth2 {
+	status = "okay";
+	managed = "in-band-status";
+	phy = <&cp1_phy1>;
+	phy-mode = "sgmii";
+	phys = <&cp1_comphy1 2>;
+};
+
+&cp1_mdio {
+	status = "okay";
+
+	cp1_phy0: ethernet-phy@4 {
+		reg = <4>;
+	};
+
+	cp1_phy1: ethernet-phy@3 {
+		reg = <3>;
+	};
+};
+
+&cp1_utmi {
+	status = "okay";
+};
+
+&cp1_usb3_0 {
+	status = "okay";
+	usb-phy = <&cp1_usb3_0_phy0>;
+	phys = <&cp1_utmi0>;
+	phy-names = "utmi";
+	dr_mode = "host";
+};
+
+&cp1_usb3_1 {
+	status = "okay";
+	usb-phy = <&cp1_usb3_0_phy1>;
+	phys =  <&cp1_comphy3 1>, <&cp1_utmi1>;
+	phy-names = "usb3", "utmi";
+	dr_mode = "host";
+};
+
+&cp1_pcie1 {
+	num-lanes = <1>;
+	phys = <&cp1_comphy4 1>;
+	status = "okay";
+};
+
+&cp1_pcie2 {
+	num-lanes = <1>;
+	phys = <&cp1_comphy5 2>;
+	status = "okay";
+};
diff --git a/target/linux/mvebu/files/arch/arm64/boot/dts/marvell/hk5131.dts b/target/linux/mvebu/files/arch/arm64/boot/dts/marvell/hk5131.dts
new file mode 100644
index 0000000000..5a9f4be284
--- /dev/null
+++ b/target/linux/mvebu/files/arch/arm64/boot/dts/marvell/hk5131.dts
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018-2021 Marvell International Ltd.
+ */
+
+#include "hk5130.dts" /* include SoC device tree */
+
+/ {
+	compatible = "hawkeye,hk-5131", "marvell,cn9131", "marvell,cn9130",
+			"marvell,armada-ap807-quad", "marvell,armada-ap807";
+};
+
+&cp0_eth0 {
+	status = "disabled";
+};
+
+&cp1_eth0 {
+	status = "disabled";
+};
diff --git a/target/linux/mvebu/files/arch/arm64/boot/dts/marvell/hk5140.dts b/target/linux/mvebu/files/arch/arm64/boot/dts/marvell/hk5140.dts
new file mode 120000
index 0000000000..0845fee895
--- /dev/null
+++ b/target/linux/mvebu/files/arch/arm64/boot/dts/marvell/hk5140.dts
@@ -0,0 +1 @@
+hk5130.dts
\ No newline at end of file
diff --git a/target/linux/mvebu/files/arch/arm64/boot/dts/marvell/hk5141.dts b/target/linux/mvebu/files/arch/arm64/boot/dts/marvell/hk5141.dts
new file mode 120000
index 0000000000..093638d458
--- /dev/null
+++ b/target/linux/mvebu/files/arch/arm64/boot/dts/marvell/hk5141.dts
@@ -0,0 +1 @@
+hk5131.dts
\ No newline at end of file
diff --git a/target/linux/mvebu/image/cortexa72.mk b/target/linux/mvebu/image/cortexa72.mk
index 47d958b2fd..65c27a1fc9 100644
--- a/target/linux/mvebu/image/cortexa72.mk
+++ b/target/linux/mvebu/image/cortexa72.mk
@@ -78,3 +78,14 @@ define Device/iei_puzzle-m902
   SOC := cn9132
 endef
 TARGET_DEVICES += iei_puzzle-m902
+
+define Device/hawkeye_hk5130
+  $(call Device/Default-arm64)
+  BOOT_SCRIPT = hawkeye
+  DEVICE_VENDOR := Hawkeye
+  DEVICE_MODEL := HK5130
+  DEVICE_PACKAGES += kmod-ath11k-pci ath11k-firmware-qcn9074
+  DEVICE_DTS := hk5130 hk5131 hk5140 hk5141
+  SOC := cn9132
+endef
+TARGET_DEVICES += hawkeye_hk5130
diff --git a/target/linux/mvebu/image/hawkeye.bootscript b/target/linux/mvebu/image/hawkeye.bootscript
new file mode 100644
index 0000000000..6c15e7cfec
--- /dev/null
+++ b/target/linux/mvebu/image/hawkeye.bootscript
@@ -0,0 +1,18 @@
+setenv bootargs "root=PARTUUID=@ROOT@-02 rw rootwait ${extra_params} ${cpuidle}"
+
+if test -n "${console}"; then
+	setenv bootargs "${bootargs} ${console}"
+fi
+
+if test -n "${fdt_addr_r}"; then
+       setenv fdt_addr ${fdt_addr_r}
+fi
+
+if test -n "${kernel_addr_r}"; then
+       setenv kernel_addr ${kernel_addr_r}
+fi
+
+load ${devtype} ${devnum}:1 ${fdt_addr} ${hkboard}.dtb
+load ${devtype} ${devnum}:1 ${kernel_addr} Image
+
+booti ${kernel_addr} - ${fdt_addr}
diff --git a/target/linux/mvebu/patches-5.15/920-hawkeye-hk5310.patch b/target/linux/mvebu/patches-5.15/920-hawkeye-hk5310.patch
new file mode 100644
index 0000000000..bfcd975218
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/920-hawkeye-hk5310.patch
@@ -0,0 +1,87 @@
+diff --git a/arch/arm64/boot/dts/marvell/armada-cp11x.dtsi b/arch/arm64/boot/dts/marvell/armada-cp11x.dtsi
+index 3bd2182817fb..fd1576c57cd0 100644
+--- a/arch/arm64/boot/dts/marvell/armada-cp11x.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-cp11x.dtsi
+@@ -227,6 +227,9 @@ CP11X_LABEL(clk): clock {
+ 				#clock-cells = <2>;
+ 			};
+ 
++			CP11X_LABEL(pinctrl): pinctrl {
++                        };
++
+ 			CP11X_LABEL(gpio1): gpio@100 {
+ 				compatible = "marvell,armada-8k-gpio";
+ 				offset = <0x100>;
+@@ -415,6 +418,18 @@ CP11X_LABEL(i2c1): i2c@701100 {
+ 			status = "disabled";
+ 		};
+ 
++		CP11X_LABEL(mss_i2c): i2c@211000 {
++                        compatible = "marvell,mv78230-i2c";
++                        reg = <0x211000 0x20>;
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++                        interrupts = <0 IRQ_TYPE_LEVEL_HIGH>;
++                        clock-names = "core", "reg";
++                        clocks = <&CP11X_LABEL(clk) 1 21>,
++                                 <&CP11X_LABEL(clk) 1 17>;
++                        status = "disabled";
++                };
++
+ 		CP11X_LABEL(uart0): serial@702000 {
+ 			compatible = "snps,dw-apb-uart";
+ 			reg = <0x702000 0x100>;
+diff --git a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
+index 11be60333fa8..369c29d32175 100644
+--- a/drivers/net/phy/realtek.c
++++ b/drivers/net/phy/realtek.c
+@@ -31,6 +31,8 @@
+ #define RTL8211F_PHYCR2				0x19
+ #define RTL8211F_INSR				0x1d
+ 
++#define RTL8211F_EEE_ENABLE			0x20
++
+ #define RTL8211F_TX_DELAY			BIT(8)
+ #define RTL8211F_RX_DELAY			BIT(3)
+ 
+@@ -334,8 +336,19 @@ static int rtl8211f_config_init(struct phy_device *phydev)
+ 	struct rtl821x_priv *priv = phydev->priv;
+ 	struct device *dev = &phydev->mdio.dev;
+ 	u16 val_txdly, val_rxdly;
++	u16 val_eee;
+ 	int ret;
+ 
++	/* Disable EEE mode */
++	val_eee = phy_read_paged(phydev, 0xa43, 0x19);
++	val_eee &= ~(RTL8211F_EEE_ENABLE);
++	phy_write_paged(phydev, 0xa43, 0x19, val_eee);
++
++
++	/* Set LED0 - SPD 100M, LED1 - LNK/ACT, LED2 - SPD 1000M */
++	phy_write_paged(phydev, 0xd04, 0x10, 0x2362);
++	phy_write_paged(phydev, 0xd04, 0x11, 0x0);
++
+ 	ret = phy_modify_paged_changed(phydev, 0xa43, RTL8211F_PHYCR1,
+ 				       RTL8211F_ALDPS_PLL_OFF | RTL8211F_ALDPS_ENABLE | RTL8211F_ALDPS_XTAL_OFF,
+ 				       priv->phycr1);
+diff --git a/drivers/power/reset/gpio-poweroff.c b/drivers/power/reset/gpio-poweroff.c
+index 1c5af2fef142..6915b5000191 100644
+--- a/drivers/power/reset/gpio-poweroff.c
++++ b/drivers/power/reset/gpio-poweroff.c
+@@ -49,10 +49,12 @@ static void gpio_poweroff_do_poweroff(void)
+ static int gpio_poweroff_probe(struct platform_device *pdev)
+ {
+ 	bool input = false;
++	bool force = false;
+ 	enum gpiod_flags flags;
+ 
+ 	/* If a pm_power_off function has already been added, leave it alone */
+-	if (pm_power_off != NULL) {
++	force = of_property_read_bool(pdev->dev.of_node, "force");
++	if (!force && pm_power_off != NULL) {
+ 		dev_err(&pdev->dev,
+ 			"%s: pm_power_off function already registered\n",
+ 		       __func__);
+-- 
+2.45.2
+
-- 
2.34.1

